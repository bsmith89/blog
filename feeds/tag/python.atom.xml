<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Deep Ecology</title><link href="http://bsmith89.github.io/blog/" rel="alternate"></link><link href="http://bsmith89.github.io/blog/feeds/tag/python.atom.xml" rel="self"></link><id>http://bsmith89.github.io/blog/</id><updated>2015-08-14T10:00:00-04:00</updated><entry><title>First Time Teaching Python to Novices</title><link href="http://bsmith89.github.io/blog/swc-python-lesson.html" rel="alternate"></link><updated>2015-08-14T10:00:00-04:00</updated><author><name>Byron J. Smith</name></author><id>tag:bsmith89.github.io,2015-08-12:blog/swc-python-lesson.html</id><summary type="html">&lt;p&gt;This July I co-instructed with &lt;a href="https://impactstory.org/JenniferShelton"&gt;Jennifer Shelton&lt;/a&gt; a Software Carpentry &lt;a href="http://i5k-kinbre-script-share.github.io/2015-07-23-stanford/"&gt;workshop&lt;/a&gt; at Stanford University, targeted to researchers with genomic or evolutionary datasets. Jennifer taught the shell (Bash) and version control with Git, while I taught the general programming language Python. I've been aware of the &lt;a href="http://software-carpentry.org/"&gt;organization&lt;/a&gt;, which teaches software development and computational methods to scientists, since attending a workshop in 2012. Since then I've served as a helper at one workshop (troubleshooting individual learner's problems and helping catch them up with the rest of the class), and gone through the &amp;quot;accelerated&amp;quot;, two day, instructor training at Michigan State University. After the Stanford workshop, I took part in new-instructor debriefing on August 4th, during which I mentioned that I had to greatly pare down the community-written lesson plan, &lt;a href="http://swcarpentry.github.io/python-novice-inflammation/"&gt;python-novice-inflammation&lt;/a&gt;, to fit into the two half-day session we allotted it.&lt;/p&gt;
&lt;p&gt;Karin and Tiffany, who were running the debriefing, asked me to send a note to the mentorship email list about which parts I removed and which I kept in. I thought I'd also take the opportunity to comment on the material at large: what worked for me and what didn't. What started as an email quickly ballooned into this blog post.&lt;/p&gt;
&lt;p&gt;To be explicit, I was teaching from the state of the repository at the time of the workshop&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;With this as my first workshop&lt;a href="#fn2" class="footnoteRef" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;, I (incorrectly) thought I could teach all of the topics straight through. By the time it became apparent that this wasn't going to work, adapting the first day's material had to be done on the fly. After that experience, and before the following afternoon, I prepared a subset of the remaining material that I thought I could cover. I'm now relying on my (somewhat traumatic) memory of the first session, and that outline I put together for the second day to write this summary.&lt;/p&gt;
&lt;p&gt;My plan going in was to split &lt;a href="http://swcarpentry.github.io/python-novice-inflammation/index.html#topics"&gt;the material&lt;/a&gt; after Topic 6, getting learners up to writing functions on the first day, so that we could discuss debugging and best-practices, and transition from the Jupyter notebook to shell scripts, the next day. Based on my co-instructors recommendation, I did not have learners do all of the challenge questions for each topic, but instead picked just one or two that I thought would be most useful.&lt;/p&gt;
&lt;p&gt;I found myself wishing (especially for Topic 1: &amp;quot;Analyzing Patient Data&amp;quot;) that some of the easier questions were integrated into the lesson itself, instead of all at the bottom. Learners should have had more chances to problem-solve early, instead of listening to me for the entirety of each topic before getting their feet wet.&lt;/p&gt;
&lt;h2 id="motivating-python"&gt;Motivating Python&lt;/h2&gt;
&lt;p&gt;For that &lt;a href="http://swcarpentry.github.io/python-novice-inflammation/01-numpy.html"&gt;first topic&lt;/a&gt; I &lt;em&gt;did&lt;/em&gt; cover everything, but wish I hadn't, since it was mostly focused on array operations and the specifics of working with NumPy (e.g. operations along axes). I appreciated that we were showing the learners powerful library features to motivate the later work, but I didn't feel like it was great for this workshop's &amp;quot;genomics&amp;quot; audience. Maybe these initial motivating sections should be targeted the same way the capstone projects are. It was also too long relative to the other sections, in my opinion.&lt;/p&gt;
&lt;p&gt;It &lt;em&gt;was&lt;/em&gt; very good, however, for introducing some python specifics, especially things that learners coming from other languages like R or Mathematica might not know (e.g. 0-indexing, slices, that variable assignment happens when each line is executed, etc.). It gave learners a chance to be surprised by their misconceptions and ask questions. We should do more of that.&lt;/p&gt;
&lt;p&gt;It would have been helpful for the lesson to have pre-built explanations for 0-indexing and right-exclusive slicing, since these were the hard parts and I'm not happy with the explanations I initially used.&lt;/p&gt;
&lt;p&gt;I found the nature of the made-up data (maximum values smooth and minimum values as a step-function along the first axis) distracting. I also didn't know what they were supposed to represent (beyond inflammation over time), so the &amp;quot;actually doing science&amp;quot; part of the motivation was a bit lost. Is there a reason we use these data?&lt;/p&gt;
&lt;h2 id="python-basics-lists-loops-conditionals-etc."&gt;Python basics: lists, loops, conditionals, etc.&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://swcarpentry.github.io/python-novice-inflammation/02-loop.html"&gt;Topics 2&lt;/a&gt; and &lt;a href="http://swcarpentry.github.io/python-novice-inflammation/03-lists.html"&gt;3&lt;/a&gt;, &amp;quot;Repeating Actions with Loops&amp;quot; and &amp;quot;Storing Multiple Values in Lists&amp;quot; respectively, were good and short. I didn't feel like I had to cut anything out. However, for-loop syntax was not explicitly covered early in the lesson plan. It wasn't until I realized I had gotten ahead of myself that we talked about loop variables, iterables&lt;a href="#fn3" class="footnoteRef" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;, and the indented code-block.&lt;/p&gt;
&lt;p&gt;I also thought the segue from Topic 1 to 2 was a bit weak. This was a theme throughout, mixing the inflammation data with much simpler stuff (e.g. looping over short strings and lists). I realize we want to keep the motivation going, but, as a first-time instructor, I found it to be distracting, and didn't know which I should be emphasizing to the learners.&lt;/p&gt;
&lt;p&gt;I also picked the wrong challenge question from Topic 1 (reverse &lt;code&gt;'Newton'&lt;/code&gt; using a loop), since we hadn't covered &lt;code&gt;range&lt;/code&gt;, &lt;code&gt;append&lt;/code&gt;ing to lists, &lt;code&gt;''.join&lt;/code&gt;, etc. What novice audience is that question appropriate for? Maybe the solution is simple and I'm just confused...&lt;/p&gt;
&lt;p&gt;The material for &lt;a href="http://swcarpentry.github.io/python-novice-inflammation/04-files.html"&gt;topic 4&lt;/a&gt;, &amp;quot;Analyzing Data from Multiple Files&amp;quot; worked well overall. The only mistake I remember was copy-pasting the big chunk of code from the lesson (looping over files and drawing sets of plots) instead of typing it out. I figured since most of the code was library calls, learners wouldn't get anything out of me taking the time to type all of it. That may have been true, but it meant the learners weren't executing the code at the same time as me, which interrupted the flow of the lesson.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://swcarpentry.github.io/python-novice-inflammation/05-cond.html"&gt;Topic 5&lt;/a&gt;, &amp;quot;Making Choice&amp;quot; (if-statements), was where things got hairy. I panicked a bit and went mostly off the lesson plan. It did not go well. When I tried to find something in the lesson to get me back on track, I wished there was more explicit discussion of syntax and booleans. I was able to review the topic the next day, which I think got any lost learners mostly caught up.&lt;/p&gt;
&lt;p&gt;As you can imagine, at this point we were nearing the end of the first day. I did manage to show the learners the syntax for defining and using functions, but I covered &lt;a href="http://swcarpentry.github.io/python-novice-inflammation/06-func.html"&gt;topic 6&lt;/a&gt;, &amp;quot;Creating Functions&amp;quot;, in its entirety at the start of the next session.&lt;/p&gt;
&lt;h2 id="learning-my-lesson"&gt;Learning my lesson&lt;/h2&gt;
&lt;p&gt;After the harrowing experience with conditionals on the first day, I took the time to write out a personalized lesson outline for the next day with learning objectives, steps in explaining difficult concepts, and pre-picked understanding/challenge questions. The exercise of writing an outline of learning objectives before the class was very helpful, and something I intend to repeat before future workshops.&lt;/p&gt;
&lt;p&gt;If I remember correctly&lt;a href="#fn4" class="footnoteRef" id="fnref4"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;, the second day I started once again with functions, and largely based the lesson on the material in &lt;a href="http://swcarpentry.github.io/python-novice-inflammation/06-func.html"&gt;the topic&lt;/a&gt;. The temperature conversion formulas were an effective motivator for this lesson. I wonder if simple examples, like this one, can replace the more complex (and, admittedly, more impressive) inflammation tutorial to demonstrate the value of Python for scientists. I also integrated material from the &lt;a href="http://swcarpentry.github.io/python-novice-inflammation/07-errors.html"&gt;topic on errors and exceptions&lt;/a&gt;: tracebacks, syntax errors, etc. In this combined topic I did not use the &lt;code&gt;import errors_01&lt;/code&gt; example. It was unclear to me why the lesson plan, as written, uses a black-box script like &lt;code&gt;errors_01.py&lt;/code&gt;, and not something more explicit, like an index or attribute error, to dissect the traceback. I think the explicit approach worked well for the learners in this workshop. Since we were covering functions anyway, it wasn't hard to get a multi-level traceback. Syntax errors also combined nicely with learning function definition syntax.&lt;/p&gt;
&lt;figure&gt;
&lt;img src="http://bsmith89.github.io/blog/static/images/swc-stanford-byron.jpg" alt="The author dissecting an attribute error." /&gt;&lt;figcaption&gt;The author dissecting an attribute error.&lt;a href="#fn5" class="footnoteRef" id="fnref5"&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Somewhere in the process of talking about functions we got sidetracked with &lt;code&gt;open()&lt;/code&gt;. I was surprised to see that the lesson plans have only limited discussion of file objects, only really dealing with them in the section on &lt;code&gt;IOErrors&lt;/code&gt;. I think learners appreciated a chance to see how the array data they had used the day before were saved as a CSV, and how they could access the data directly. It also gave us a chance to show that other objects besides lists and strings can serve as iterators in for-loops.&lt;/p&gt;
&lt;p&gt;I liked how the topic 6 &lt;a href="http://swcarpentry.github.io/python-novice-inflammation/06-func.html#defining-defaults"&gt;lesson plan&lt;/a&gt; used the library function &lt;code&gt;numpy.loadtxt()&lt;/code&gt; to talk about default arguments and the &lt;code&gt;help()&lt;/code&gt; built-in. I jumped back and forth between examining that function and implementing the same things (keywords, documentation) in a &lt;code&gt;center()&lt;/code&gt; function we were building. The realized lesson was very similar to the repository's lesson plan, but a little more integrated with errors and exceptions.&lt;/p&gt;
&lt;p&gt;I had the learners implement &lt;code&gt;rescale()&lt;/code&gt; as a challenge question. We then worked together as a class to add lower and upper bounds. This was a much more difficult task than I expected (even just deriving the correct formula), and served nicely to demonstrate defensive programming and debugging. While we touched on many of the concepts in &lt;a href="http://swcarpentry.github.io/python-novice-inflammation/08-defensive.html"&gt;topics 8&lt;/a&gt; and &lt;a href="http://swcarpentry.github.io/python-novice-inflammation/09-debugging.html"&gt;9&lt;/a&gt;, these ideas, were spread throughout, and I did not walk through either as an atomic lesson.&lt;/p&gt;
&lt;p&gt;My ultimate goal on the second day was to write a program to calculate the mean inflammation of each subject in the example files and then transform the program into a command-line script that would operate as a UNIX-style filter. I remember Greg Wilson teaching Python scripting (along with Bash and SQL) that way during my first workshop (as a &lt;em&gt;learner&lt;/em&gt;!) at MSU in May 2012&lt;a href="#fn6" class="footnoteRef" id="fnref6"&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;. This &lt;a href="http://swcarpentry.github.io/python-novice-inflammation/10-cmdline.html"&gt;last topic&lt;/a&gt; seemed like a worthwhile mini-capstone, since it would reintroduce ideas from the Bash lesson the day before, and we could version-control our work with git. While we managed to run our code as a script (rather than a cell in the Jupyter notebook), the transition was a little rough around the edges, and we didn't have time to add &lt;code&gt;sys.argv&lt;/code&gt; or &lt;code&gt;sys.stdin&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="take-aways"&gt;Take-aways&lt;/h2&gt;
&lt;p&gt;The second day of Python was much smoother than the first, and, while we did not get to all of the material, I was satisfied with what we did cover. It's quite remarkable that learners can go all the way from indexing into lists to defensive programming and unit tests in just a few hours. I'm not convinced that we got them far enough to jump right into using Python for their own work, but I hope it was a good kick-start towards that goal. I'm amazed some novice workshops only allocate a half-day session to the programming language (be it Python, R, or Matlab), although a quick survey of &lt;a href="http://software-carpentry.org/workshops/index.html#future"&gt;upcoming workshops&lt;/a&gt; suggests that almost &lt;em&gt;all&lt;/em&gt; of them do in fact use two sessions. Is this the recommended approach (and if so where is it documented) or have many instructors all independently come to the same conclusion?&lt;/p&gt;
&lt;p&gt;Even so, there's still more material in python-novice-inflammation than can be covered in two sessions. I'm under the impression that the repository is sort of &lt;em&gt;meant&lt;/em&gt; to be like that: way too big, so that instructors can pick and choose the parts that are most salient for their audience. This seems like a good idea, but it was not sufficiently communicated to me as a first-time instructor, and, while many of the difficulties I had could have been solved with more comprehensive preparation, having a &amp;quot;default&amp;quot; subset would have been helpful.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;&lt;a href="https://github.com/swcarpentry/python-novice-inflammation/tree/76e3ea24406e4b8d684c9b45f3c5fd33e23ac71a"&gt;&lt;code&gt;76e3ea24406e4b8d684c9b45f3c5fd33e23ac71a&lt;/code&gt;&lt;/a&gt;: still the HEAD as of this writing.&lt;a href="#fnref1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;and being insufficiently prepared&lt;a href="#fnref2"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;Actually, we talked about getting values from lists and how strings are like lists, rather than about iterables in general.&lt;a href="#fnref3"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn4"&gt;&lt;p&gt;Despite the fact that I have those notes, I actually don't remember the details of that day's lesson as well. I wonder if there's some weird metamemory thing going on e.g. &lt;a href="http://www.sciencemag.org/content/333/6043/776.abstract"&gt;this&lt;/a&gt; (unfortunately paywalled).&lt;a href="#fnref4"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn5"&gt;&lt;p&gt;Photo credit: Amy Hodge (&lt;a href="https://creativecommons.org/licenses/by/2.0/"&gt;CC-BY&lt;/a&gt;)&lt;a href="#fnref5"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn6"&gt;&lt;p&gt;The site for this historic event can still be found &lt;a href="https://web.archive.org/web/20120514195748/http://software-carpentry.org/boot-camps/michigan-state-university-may-2012/"&gt;here&lt;/a&gt;.&lt;a href="#fnref6"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</summary><category term="software-carpentry"></category><category term="teaching"></category><category term="programming"></category><category term="mistakes"></category><category term="python"></category></entry><entry><title>Compiling SciPy on RHEL6</title><link href="http://bsmith89.github.io/blog/scipy-on-rhel.html" rel="alternate"></link><updated>2013-05-20T12:00:00-04:00</updated><author><name>Byron J. Smith</name></author><id>tag:bsmith89.github.io,2013-05-20:blog/scipy-on-rhel.html</id><summary type="html">&lt;p&gt;Within the past two years I've discovered something interesting about myself (...actually really, &lt;em&gt;really&lt;/em&gt; boring about myself): I can be happily entertained for hours on end setting up my computational environment &lt;em&gt;just&lt;/em&gt; right. I find that it gives me a similar type of satisfaction to cataloguing my music collection. I guess you could call it a hobby.&lt;/p&gt;
&lt;p&gt;Usually this entails installing the usual suspects (&lt;code&gt;NumPy&lt;/code&gt;, &lt;code&gt;Pandas&lt;/code&gt;, &lt;code&gt;IPython&lt;/code&gt;, &lt;code&gt;matplotlib&lt;/code&gt;, etc.) in a python &lt;a href="http://www.virtualenv.org/en/latest/"&gt;virtual environment&lt;/a&gt;. When I'm particularly into it (which is always), I'll also compile the python distribution itself. I've had several opportunities to indulge this pasttime, most recently in setting up my research pipeline on the &lt;a href="http://cac.engin.umich.edu/resources/systems/flux"&gt;Flux&lt;/a&gt; high-performance compute cluster at The University of Michigan.&lt;/p&gt;
&lt;p&gt;Installing &lt;code&gt;NumPy&lt;/code&gt; is usually no trouble at all, but for some reason (if you know, please tell me), &lt;code&gt;SciPy&lt;/code&gt; has &lt;em&gt;always&lt;/em&gt; given me a &amp;quot;BlasNotFoundError&amp;quot; when installing on the Red Hat Enterprise Linux distros commonly used on academic clusters.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;&amp;gt;&lt;/span&gt; pip install scipy
&lt;span class="go"&gt;Downloading/unpacking scipy&lt;/span&gt;
&lt;span class="go"&gt;  Downloading scipy-0.12.0.zip (10.2MB): 100% 10.2MB downloaded&lt;/span&gt;
&lt;span class="go"&gt;...&lt;/span&gt;
&lt;span class="go"&gt;numpy.distutils.system_info.BlasNotFoundError:&lt;/span&gt;
&lt;span class="go"&gt;    Blas (http://www.netlib.org/blas/) libraries not found.&lt;/span&gt;
&lt;span class="go"&gt;    Directories to search for the libraries can be specified in the&lt;/span&gt;
&lt;span class="go"&gt;    numpy/distutils/site.cfg file (section [blas]) or by setting&lt;/span&gt;
&lt;span class="go"&gt;    the BLAS environment variable.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I &lt;em&gt;know&lt;/em&gt; BLAS and LAPACK are installed as shared libraries: at Michigan State University I had to load the respective modules, but at UMich they're right there in &lt;code&gt;/usr/lib64/atlas&lt;/code&gt;. So why &lt;code&gt;pip install SciPy&lt;/code&gt; always gives me that error, I have no clue. I've set the BLAS and LAPACK environmental variables to the relevant shared libraries. I've run &lt;code&gt;python setup.py build --fcompiler=gnu95&lt;/code&gt; directly. But I always got that same error.&lt;/p&gt;
&lt;p&gt;Anyway, I &lt;em&gt;finally&lt;/em&gt; got it to work, so I thought I'd share the steps I took just in case it helps someone else. My solution was found on Stack Overflow (surprise, surprise): The accepted answer to &lt;a href="http://stackoverflow.com/q/7496547/848121"&gt;this&lt;/a&gt; question.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;mkdir -p ~/.local/src/
&lt;span class="nb"&gt;cd&lt;/span&gt; ~/.local/src/
wget -O BLAS.tgz http://www.netlib.org/blas/blas.tgz
tar -xzf BLAS.tgz
&lt;span class="nb"&gt;cd &lt;/span&gt;BLAS
gfortran -O3 -std&lt;span class="o"&gt;=&lt;/span&gt;legacy -m64 -fno-second-underscore -fPIC -c *.f
ar r libfblas.a *.o
ranlib libfblas.a
&lt;span class="nb"&gt;export &lt;/span&gt;&lt;span class="nv"&gt;BLAS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$PWD&lt;/span&gt;/libfblas.a

&lt;span class="nb"&gt;cd&lt;/span&gt; ~/.local/src/
wget -O LAPACK.tgz http://www.netlib.org/lapack/lapack.tgz
tar -xzf LAPACK.tgz
&lt;span class="c"&gt;# The resulting directory may be named lapack-&amp;lt;version&amp;gt;/&lt;/span&gt;
&lt;span class="c"&gt;# the following assumes that it&amp;#39;s named LAPACK/&lt;/span&gt;
&lt;span class="nb"&gt;cd &lt;/span&gt;LAPACK
cp INSTALL/make.inc.gfortran make.inc
vim make.inc
&lt;span class="c"&gt;# Change OPTS = -O2 to OPTS = -O2 -fPIC&lt;/span&gt;
&lt;span class="c"&gt;# Change NOOPT = -O0 to NOOPT = -O0 -fPIC&lt;/span&gt;
make lapacklib
&lt;span class="nb"&gt;export &lt;/span&gt;&lt;span class="nv"&gt;LAPACK&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$PWD&lt;/span&gt;/libflapack.a

&lt;span class="nb"&gt;cd&lt;/span&gt; ~/.local/src/
git clone https://github.com/scipy/scipy.git
&lt;span class="nb"&gt;cd &lt;/span&gt;scipy
python setup.py build --fcompiler gnu95
python setup.py install
&lt;span class="c"&gt;# Assuming you&amp;#39;re already in the virtualenv you want to install to.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I don't know which other systems this will work on, but it does successfully install SciPy for me. On Python 3.3.2, running the unit tests give me several errors and failures (nothing too scary looking), but everything passes on Python 2.7.5!&lt;/p&gt;
&lt;p&gt;Enjoy.&lt;/p&gt;
</summary><category term="python"></category><category term="hpc"></category><category term="software"></category><category term="scipy"></category><category term="linux"></category></entry><entry><title>PyMake I: Another GNU Make Clone</title><link href="http://bsmith89.github.io/blog/pymake-0.html" rel="alternate"></link><updated>2015-07-15T08:00:00-04:00</updated><author><name>Byron J. Smith</name></author><id>tag:bsmith89.github.io,2013-05-07:blog/pymake-0.html</id><summary type="html">&lt;p&gt;&lt;del&gt;&lt;em&gt;This is the first of two posts about my program &lt;a href="http://github.com/bsmith89/pymake/"&gt;PyMake&lt;/a&gt;. I'll post the link to Part II here when I've written it.&lt;/em&gt;&lt;/del&gt; &lt;em&gt;While I still agree with some of the many of the views expressed in this piece, I have changed my thinking on Makefiles. I'll post a new post about the topic when I take the time to write it.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;I am an aspiring but unskilled (not yet skilled?) computer geek. You can observe this for yourself by watching me fumble my way through &lt;a href="https://github.com/bsmith89/dotfiles"&gt;&lt;code&gt;vim&lt;/code&gt; configuration&lt;/a&gt;, multi-threading/processing in Python, and &lt;code&gt;git&lt;/code&gt; merges.&lt;/p&gt;
&lt;p&gt;Rarely do I actually feel like my products are worth sharing with the wider world. The only reason I have a GitHub account is personal convenience and absolute confidence that no one else will ever look at it besides me. (Yes, I realize that I am invalidating the previous sentence with that glaring &amp;quot;Fork me on GitHub&amp;quot; ribbon in the top-right corner of this page. I'm putting myself out there! OKAY?!)&lt;/p&gt;
&lt;p&gt;As an aspiring scientist, too, I've had plenty of opportunities to practice the relevant skill sets. A laboratory rotation with &lt;a href="http://ivory.idyll.org/blog/"&gt;Titus Brown&lt;/a&gt;, and the resulting exposure to his reproducible research and &lt;a href="http://software-carpentry.org"&gt;Software Carpentry&lt;/a&gt; evangelizing, has certainly influenced the tools and techniques in my belt.&lt;/p&gt;
&lt;p&gt;I try to use the &lt;code&gt;NumPy&lt;/code&gt;/&lt;code&gt;SciPy&lt;/code&gt;/&lt;code&gt;Pandas&lt;/code&gt;/&lt;code&gt;matplotlib&lt;/code&gt; stack for my computational and visualization tasks. I am a relatively competent &lt;code&gt;BASH&lt;/code&gt;-ist and I work hard to write my scripts so that they'll make sense to me 5 years from now. I have even been known to do some of my data analysis in IPython notebooks.&lt;/p&gt;
&lt;h1 id="a-pipeline-is-only-sometimes-a-makefile"&gt;A Pipeline is only sometimes a Makefile&lt;/h1&gt;
&lt;p&gt;Despite (or maybe because of) my obsession with writing simple, reproducible pipelines, one tool I have never come to terms with is GNU &lt;code&gt;make&lt;/code&gt;. While it's not quite mainstream for bioinformaticians and other computational folk, &lt;code&gt;make&lt;/code&gt; &lt;a href="http://archive.nodalpoint.org/2007/03/18/a_pipeline_is_a_makefile"&gt;promises&lt;/a&gt; to tie all those *&lt;code&gt;NIX&lt;/code&gt; style scripts together seamlessly and with built-in parallelization, selective re-running, and more, all under a declarative language syntax. I say 'promises' because, for me, it never did any of those things.&lt;/p&gt;
&lt;p&gt;Now, I don't want to suggest that this ubiquitous piece of GNU software doesn't work well. I recognize that it does much of what the average user needs, but for my particular pipeline it just wasn't the right tool.&lt;/p&gt;
&lt;p&gt;My problem was a seemingly simple one. I had a set of gene models (HMMs) and a set of FASTQ formatted sequences from an Illumina sequencer. The goal was to search every sample for every gene using HMMER3 and to output the results (plus a respectable amount of pre- and post-processing). The problem is, &lt;code&gt;make&lt;/code&gt; is designed for software compilation. Processing &lt;code&gt;foo.c&lt;/code&gt; and &lt;code&gt;bar.h&lt;/code&gt; into &lt;code&gt;foo.o&lt;/code&gt; is easy. I, however, was asking &lt;code&gt;make&lt;/code&gt; to generate the product of &lt;span class="math inline"&gt;&lt;em&gt;n&lt;/em&gt;&lt;/span&gt; samples and &lt;span class="math inline"&gt;&lt;em&gt;m&lt;/em&gt;&lt;/span&gt; models (&lt;strong&gt;complete aside&lt;/strong&gt;: if you're curious about how I got the &lt;span class="math inline"&gt;$\LaTeX$&lt;/span&gt; formatting, see &lt;a href="http://www.ceremade.dauphine.fr/~amic/blog/mathjax-and-pelican-en.html"&gt;this&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;While, after a dozen hours of smashing my head against the table, I was able to get my &lt;code&gt;Makefile&lt;/code&gt; to work, it required some &lt;em&gt;really&lt;/em&gt; ugly tricks like secondary expansion and gratuitous calls to &lt;code&gt;sed&lt;/code&gt; in my macros (for others with similar problems see &lt;a href="http://stackoverflow.com/q/3745177/848121"&gt;here&lt;/a&gt;, and &lt;a href="http://stackoverflow.com/q/2880975/848121"&gt;here&lt;/a&gt;). Plus, debugging &lt;code&gt;make&lt;/code&gt; is torture, surely against the Geneva Conventions.&lt;/p&gt;
&lt;p&gt;I &lt;em&gt;wanted&lt;/em&gt; to use &lt;code&gt;make&lt;/code&gt;, I swear I did. It's open source, well used, extensively tested, available on all relevant systems, etc. And I probably could have... but only by keeping the ugly hack or hard-coding the recipe for each model, and that just didn't jive with my recently acquired simple/reproducible mentality. Converts always are the most zealous, afterall.&lt;/p&gt;
&lt;h1 id="they-say-graduate-school-is-a-time-to-explore"&gt;They say graduate school is a time to explore&lt;/h1&gt;
&lt;p&gt;So what did I do? No, I didn't immediately start writing a make replacement with all of the features I wanted like some over-eager graduate student. Jeeze! What do you people think of me!? First I checked out the &lt;a href="http://freecode.com/articles/make-alternatives"&gt;extant alternatives&lt;/a&gt;... I hated everything. So &lt;em&gt;then&lt;/em&gt; I started writing a make replacement with all of the features I wanted.&lt;/p&gt;
&lt;p&gt;The result was one of the first pieces of general purpose software to come off my laptop which I wouldn't be entirely ashamed to show to an experienced programmer. It's rough, don't get me wrong, but it does everything I need and is actually kinda pretty internally. Well, at least it was before I fixed some glaring problems. Whatever. The point is I want to share &lt;a href="https://github.com/bsmith89/pymake"&gt;it&lt;/a&gt; with the world; what better stage exists for its introduction than this blog, which absolutely no one reads?&lt;/p&gt;
&lt;p&gt;...Yeah, I'll probably post it to &lt;a href="http://reddit.com/r/python"&gt;/r/python&lt;/a&gt; too.&lt;/p&gt;
&lt;p&gt;Tune in for Part II, in which I explain why &lt;em&gt;you&lt;/em&gt; should use my software.&lt;/p&gt;
</summary><category term="python"></category><category term="software"></category><category term="development"></category><category term="make"></category><category term="pipelines"></category><category term="bioinformatics"></category></entry></feed>